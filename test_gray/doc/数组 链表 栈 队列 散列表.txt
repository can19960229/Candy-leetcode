数组：顺序存储
    读操作多，写操作少
    1.读取(查找)元素：读取对应的下标
            高效的查找元素的算法：二分查找
    2.更新元素：对元素进行重新赋值
    3.插入元素：尾部插入、中间插入、超范围插入
            扩容问题，时间复杂度：O(n)
            插入并移动元素，时间复杂度：O(n)
    4.删除元素：1. 删除对应位置，后面的元素往前挪
               2. 把最后一个元素复制到删除元素所在的位置，再删除最后一个元素
                删除元素，时间复杂度：O(n)



链表：随机存储
    单链表
    1.查找节点：时间复杂度：O(n)
        从头节点开始向后一个一个节点逐一查找
    2.更新节点：旧数据替换成新数据即可，时间复杂度：O(1)
    3.插入节点：尾部插入、中间插入、头部插入，时间复杂度：O(1)
        尾部插入：把最后一个节点的next指针指向新插入的节点
        头部插入：把新节点的next指针指向原先的头节点
                 把新节点变成链表的头节点
        中间插入：插入位置的前置节点的next指针指向插入的新节点
                 将新节点的next指针指向前置节点的next指针原先所指向的节点
    4.删除节点：尾部删除、头部删除、中间删除，时间复杂度：O(1)
        尾部删除：直接将倒数第二个节点的next指针指向空即可
        头部删除：链表的头节点设为原先头节点的next指针即可
        中间删除：把删除及诶单的前置节点的next指针指向要删除元素的下一个节点

栈：
    先进后出,FILO
    1. 入栈 时间复杂度：O(1)
    2. 出栈 时间复杂度：O(1)

队列：
    先进先出 FIFO
    出口端叫队头，入口端叫队尾

    1. 循环队列：
        队列满了的判定条件： (队尾下标 + 1） % 数组长度 = 队头下标
        (rear + 1 )%array.length == front
        队列最大容量比数组长度小1
    2. 双端队列：
        结合了栈和队列的特点，既可以先进先出，也可以先入后出
        从队头一端可以出队或入队，从队尾一端也可以出队或入队
    3. 优先队列：
        谁的优先级高，谁先出队（二叉堆实现的）

散列表（哈希表）：hash table
    散列表实现类(HashMap)
    提供了键(Key)和值(Value)的映射关系，只要给出一个Key就可以高效的找出匹配的Value，时间复杂度：O(1)
    基本原理：
        本质上是一个数组
    1. 哈希函数
        通过某种方式，把Key和数组下标进行转换，这个转换的中转站就叫做哈希函数
        hashcode
        HashMap
        通过哈希函数，我们可以把字符串或者其他类型的key转换成数组的下标index,想要转化成数组的下标，做简单的转换方式是按照数组长度当进行取模运算
            index = HashCode(key) % Array.length
        例：给出一个长度为8的数组，当
            key = 5720153303时，
                index = HashCode("5720153303") % Array.length = 1420036703 % 8 = 7
            key = this时，
                index = HashCode("this") % Array.length = 3559070 % 8 = 6
    2.散列表的读写操作:
        (1) 写操作：put
            就是在散列表中插入新的键值对（Entry）  hashMap.put("2020619","张三")
            哈希冲突：
               数组的长度有限，当插入的Entry越来越多时，不同的Key通过哈希函数获得的下标有可能是相同的，则产生哈希冲突
              解决方法：
                1. 开放寻址法
                    原理：当一个Key通过哈希函数获得对应的数组下标已经被占用时，则寻找下一个空档位置
                    应用：在java中，ThreadLocal使用的就是开放寻址法
                2. 链表法
                    原理：HashMap数组的每一个元素不仅是一个Entry对象，还是一个链表的头节点，每一个Entry对象通过next指针指向它的下一个Entry节点
                        当新的Entry映射与之冲突时，则与该位置为头节点，插入到该链表中
                    应用：java中的HashMap
        (2) 读操作：get
            通过给定的Key,在散列表中查找对应的Value
            步骤：
                1. 通过哈希函数，把Key转换成数组下标
                2. 如果不冲突，则返回对应的Value; 如果冲突，则顺着链表往下找，查找匹配的节点
        (3) 扩容：resize
            当大量元素拥挤在相同数组下标位置，形成很长的链表，对后续插入和查询会有很大影响，则需要对散列表进行扩容
            散列表实现类(HashMap)而言，扩容因素：
                1. Capacity,即HashMap的当前长度
                2. LoadFactor,即HashMap的负载因子，默认为0.75f
                扩容条件：HashMap.Size >= Capacity x LoadFactor
            扩容步骤：
                1. 扩容：创建一个新的Entry数组，长度为原来的2倍
                2. 重新Hash：遍历元Entry数组，把原来的Entry重新Hash到新数组中。
                   重新Hash是因为长度扩大，Hash的规则也随之改变。原本拥挤的散列表重新变得稀疏，原来的Entry也红心得到尽可能的均匀分配


